// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"github.com/fitan/magic/model"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"
)

func newSysUser(db *gorm.DB) sysUser {
	_sysUser := sysUser{}

	_sysUser.sysUserDo.UseDB(db)
	_sysUser.sysUserDo.UseModel(&model.SysUser{})

	tableName := _sysUser.sysUserDo.TableName()
	_sysUser.ALL = field.NewField(tableName, "*")
	_sysUser.Active = field.NewInt(tableName, "active")
	_sysUser.APIToken = field.NewString(tableName, "api_token")
	_sysUser.AuthType = field.NewInt(tableName, "auth_type")
	_sysUser.CreatedAt = field.NewTime(tableName, "created_at")
	_sysUser.Displayname = field.NewString(tableName, "displayname")
	_sysUser.Email = field.NewString(tableName, "email")
	_sysUser.Id = field.NewInt64(tableName, "id")
	_sysUser.LoginFrequency = field.NewInt(tableName, "login_frequency")
	_sysUser.Name = field.NewString(tableName, "name")
	_sysUser.OnlyOss = field.NewInt(tableName, "only_oss")
	_sysUser.Password = field.NewString(tableName, "password")
	_sysUser.Phone = field.NewString(tableName, "phone")
	_sysUser.Role = field.NewInt(tableName, "role")
	_sysUser.UpdatedAt = field.NewTime(tableName, "updated_at")
	_sysUser.SysRoles = sysUserSysRoles{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("SysRoles", "model.SysRole"),
		SysPermissions: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("SysRoles.SysPermissions", "model.SysPermission"),
		},
	}

	_sysUser.SysServicetree = sysUserSysServicetree{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("SysServicetree", "model.TblServicetree"),
	}

	_sysUser.fillFieldMap()

	return _sysUser
}

type sysUser struct {
	sysUserDo sysUserDo

	ALL            field.Field
	Active         field.Int
	APIToken       field.String
	AuthType       field.Int
	CreatedAt      field.Time
	Displayname    field.String
	Email          field.String
	Id             field.Int64
	LoginFrequency field.Int
	Name           field.String
	OnlyOss        field.Int
	Password       field.String
	Phone          field.String
	Role           field.Int
	UpdatedAt      field.Time
	SysRoles       sysUserSysRoles

	SysServicetree sysUserSysServicetree

	fieldMap map[string]field.Expr
}

func (s sysUser) As(alias string) *sysUser {
	s.sysUserDo.DO = *(s.sysUserDo.As(alias).(*gen.DO))

	s.ALL = field.NewField(alias, "*")
	s.Active = field.NewInt(alias, "active")
	s.APIToken = field.NewString(alias, "api_token")
	s.AuthType = field.NewInt(alias, "auth_type")
	s.CreatedAt = field.NewTime(alias, "created_at")
	s.Displayname = field.NewString(alias, "displayname")
	s.Email = field.NewString(alias, "email")
	s.Id = field.NewInt64(alias, "id")
	s.LoginFrequency = field.NewInt(alias, "login_frequency")
	s.Name = field.NewString(alias, "name")
	s.OnlyOss = field.NewInt(alias, "only_oss")
	s.Password = field.NewString(alias, "password")
	s.Phone = field.NewString(alias, "phone")
	s.Role = field.NewInt(alias, "role")
	s.UpdatedAt = field.NewTime(alias, "updated_at")

	s.fillFieldMap()

	return &s
}

func (s *sysUser) WithContext(ctx context.Context) *sysUserDo { return s.sysUserDo.WithContext(ctx) }

func (s sysUser) TableName() string { return s.sysUserDo.TableName() }

func (s *sysUser) GetFieldByName(fieldName string) (field.Expr, bool) {
	field, ok := s.fieldMap[fieldName]
	return field, ok
}

func (s *sysUser) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 16)
	s.fieldMap["active"] = s.Active
	s.fieldMap["api_token"] = s.APIToken
	s.fieldMap["auth_type"] = s.AuthType
	s.fieldMap["created_at"] = s.CreatedAt
	s.fieldMap["displayname"] = s.Displayname
	s.fieldMap["email"] = s.Email
	s.fieldMap["id"] = s.Id
	s.fieldMap["login_frequency"] = s.LoginFrequency
	s.fieldMap["name"] = s.Name
	s.fieldMap["only_oss"] = s.OnlyOss
	s.fieldMap["password"] = s.Password
	s.fieldMap["phone"] = s.Phone
	s.fieldMap["role"] = s.Role
	s.fieldMap["updated_at"] = s.UpdatedAt

}

func (s sysUser) clone(db *gorm.DB) sysUser {
	s.sysUserDo.ReplaceDB(db)
	return s
}

type sysUserSysRoles struct {
	db *gorm.DB

	field.RelationField

	SysPermissions struct {
		field.RelationField
	}
}

func (a sysUserSysRoles) Where(conds ...field.Expr) *sysUserSysRoles {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a sysUserSysRoles) WithContext(ctx context.Context) *sysUserSysRoles {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a sysUserSysRoles) Model(m *model.SysUser) *sysUserSysRolesTx {
	return &sysUserSysRolesTx{a.db.Model(m).Association(a.Name())}
}

type sysUserSysRolesTx struct{ tx *gorm.Association }

func (a sysUserSysRolesTx) Find() (result *model.SysRole, err error) {
	return result, a.tx.Find(&result)
}

func (a sysUserSysRolesTx) Append(values ...*model.SysRole) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a sysUserSysRolesTx) Replace(values ...*model.SysRole) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a sysUserSysRolesTx) Delete(values ...*model.SysRole) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a sysUserSysRolesTx) Clear() error {
	return a.tx.Clear()
}

func (a sysUserSysRolesTx) Count() int64 {
	return a.tx.Count()
}

type sysUserSysServicetree struct {
	db *gorm.DB

	field.RelationField
}

func (a sysUserSysServicetree) Where(conds ...field.Expr) *sysUserSysServicetree {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a sysUserSysServicetree) WithContext(ctx context.Context) *sysUserSysServicetree {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a sysUserSysServicetree) Model(m *model.SysUser) *sysUserSysServicetreeTx {
	return &sysUserSysServicetreeTx{a.db.Model(m).Association(a.Name())}
}

type sysUserSysServicetreeTx struct{ tx *gorm.Association }

func (a sysUserSysServicetreeTx) Find() (result *model.TblServicetree, err error) {
	return result, a.tx.Find(&result)
}

func (a sysUserSysServicetreeTx) Append(values ...*model.TblServicetree) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a sysUserSysServicetreeTx) Replace(values ...*model.TblServicetree) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a sysUserSysServicetreeTx) Delete(values ...*model.TblServicetree) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a sysUserSysServicetreeTx) Clear() error {
	return a.tx.Clear()
}

func (a sysUserSysServicetreeTx) Count() int64 {
	return a.tx.Count()
}

type sysUserDo struct{ gen.DO }

func (s sysUserDo) Debug() *sysUserDo {
	return s.withDO(s.DO.Debug())
}

func (s sysUserDo) WithContext(ctx context.Context) *sysUserDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s sysUserDo) Clauses(conds ...clause.Expression) *sysUserDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s sysUserDo) Not(conds ...gen.Condition) *sysUserDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s sysUserDo) Or(conds ...gen.Condition) *sysUserDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s sysUserDo) Select(conds ...field.Expr) *sysUserDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s sysUserDo) Where(conds ...gen.Condition) *sysUserDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s sysUserDo) Order(conds ...field.Expr) *sysUserDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s sysUserDo) Distinct(cols ...field.Expr) *sysUserDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s sysUserDo) Omit(cols ...field.Expr) *sysUserDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s sysUserDo) Join(table schema.Tabler, on ...field.Expr) *sysUserDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s sysUserDo) LeftJoin(table schema.Tabler, on ...field.Expr) *sysUserDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s sysUserDo) RightJoin(table schema.Tabler, on ...field.Expr) *sysUserDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s sysUserDo) Group(cols ...field.Expr) *sysUserDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s sysUserDo) Having(conds ...gen.Condition) *sysUserDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s sysUserDo) Limit(limit int) *sysUserDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s sysUserDo) Offset(offset int) *sysUserDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s sysUserDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *sysUserDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s sysUserDo) Unscoped() *sysUserDo {
	return s.withDO(s.DO.Unscoped())
}

func (s sysUserDo) Create(values ...*model.SysUser) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s sysUserDo) CreateInBatches(values []*model.SysUser, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s sysUserDo) Save(values ...*model.SysUser) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s sysUserDo) First() (*model.SysUser, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysUser), nil
	}
}

func (s sysUserDo) Take() (*model.SysUser, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysUser), nil
	}
}

func (s sysUserDo) Last() (*model.SysUser, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysUser), nil
	}
}

func (s sysUserDo) Find() ([]*model.SysUser, error) {
	result, err := s.DO.Find()
	return result.([]*model.SysUser), err
}

func (s sysUserDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SysUser, err error) {
	buf := make([]*model.SysUser, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s sysUserDo) FindInBatches(result *[]*model.SysUser, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s sysUserDo) Attrs(attrs ...field.AssignExpr) *sysUserDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s sysUserDo) Assign(attrs ...field.AssignExpr) *sysUserDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s sysUserDo) Joins(field field.RelationField) *sysUserDo {
	return s.withDO(s.DO.Joins(field))
}

func (s sysUserDo) Preload(field field.RelationField) *sysUserDo {
	return s.withDO(s.DO.Preload(field))
}

func (s sysUserDo) FirstOrInit() (*model.SysUser, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysUser), nil
	}
}

func (s sysUserDo) FirstOrCreate() (*model.SysUser, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysUser), nil
	}
}

func (s sysUserDo) FindByPage(offset int, limit int) (result []*model.SysUser, count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	result, err = s.Offset(offset).Limit(limit).Find()
	return
}

func (s sysUserDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s *sysUserDo) withDO(do gen.Dao) *sysUserDo {
	s.DO = *do.(*gen.DO)
	return s
}
